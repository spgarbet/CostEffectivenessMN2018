---
title: "Notes and Exercises"
author: "Shawn Garbett"
date: "7/24-26/2018"
output: html_document
---

```{r setup, include=FALSE}
library(msm)
library(tangram)
library(dplyr)
library(ggplot2)
library(dampack)
library(scales)
library(ellipse)
library(truncnorm)
library(reshape2)
library(plotrix)
library(lhs)
library(matrixStats)
knitr::opts_chunk$set(echo = TRUE)
source("Functions.R")
```

# Day 1

Attending [Cost-Effectiveness and Decision Modeling using R Workshop](http://www.sph.umn.edu/events-calendar/decision-modeling-using-r-workshop/) from July 24th-26th at the University of Minnesota.

Very nice group and program they have here.

## Handbook
In addition, as part of the [darthworkgroup.com](Decision Analysis in R for Technologies in Health \(DARTH\) working group), we have prepared a handbook titled "An Introduction to R for Decision Modelers". You can download the [handbook](https://github.com/DARTH-git/Handbook-R/blob/master/Handbook_in_R_markdown.pdf) to use as a refresher or a tutorial on the use of R prior to the workshop. You can download the data [Here](https://raw.githubusercontent.com/DARTH-git/Handbook-R/master/Course_data.txt).

## Course Materials

Please note that course materials will be shared through Google Drive. Participants’ material will be available by Friday July 20th on the following link:
[Google Drive](https://drive.google.com/drive/folders/1xceAHNEg77EwFCjSW9NGePK6UslskQys?usp=sharing)
The solutions to the exercises will be uploaded daily by the end of each day to the following link: [Google Drive](https://drive.google.com/drive/folders/1yOqNdpVSs_n13c4_xHqQjCSk2VSALYl5?usp=sharing)

## Notes Day 1

* Decision
    * Benefits
    * Harms
    * Costs
* Perspective
* Intervention
* Population
* Comparator
* Scope
* Time horizon
* Trial based Cost Effectiveness Analysis (CEA)
* Model-based CEA

Societal vs. Healthcare

Incremental Cost vs. Incremental Health Effect

For ICER denominator, do sensitivity analysis and VOI analysis to see what parameter to pursue to answer question.

UK researchers ICER plane representations are different.

2010 ACA doesn't allow cost per QALY. [New York Times article](https://www.nytimes.com/2014/12/16/upshot/forbidden-topic-in-health-policy-debate-cost-effectiveness.html)

Loss aversion involves prospect theory. Questionable weighting of probabilities.

Net Monetary Benefit (NMB), ie. Willingness to Pay threshold (WTP)

Decision Trees
* Squares are decisions
* Circles are probilities

## First Exercise: Decision Tree in Colorectal Cancer

```{r}

# Some helpers
first  <- function(x) unlist(lapply(results, function(y) y[1]))
second <- function(x) unlist(lapply(results, function(y) y[2]))

# Define parameters
strategies <- list(
  RP = "Routine Practice",
  PC = "Primary Care",
  HC = "Hospital Care"
)

params <- list(
  # Probabilities of early detection via stategy
  p.PCed = 0.40,
  p.HCed = 0.45,
  p.RPed = 0.35,
  
  # Life Expectancies, early vs. late detection
  le.ed  = 7,
  le.ld  = 1,
  
  # Costs stategy, versus detection
  c.PCed = 3900,
  c.HCed = 6200,
  c.RPed = 3030,
  c.PCld = 12800,
  c.HCld = 14400,
  c.RPld = 12020
)

results <- lapply(names(strategies), function(s) {
  with(params, {
    prob   <- get(paste0("p.", s, "ed"))
    out.ed <- c(get(paste0("c.", s, "ed")), le.ed)
    out.ld <- c(get(paste0("c.", s, "ld")), le.ld)

    # Early + Late
    prob*out.ed + (1-prob)*out.ld
  })
})

names(results) <- names(strategies)
```

```{r, results='asis'}
icer <- rep(NA, 3)
for(i in 2:length(results))
{
  compare <- results[[i-1]]
  this    <- results[[i]]
  
  icer[i] <- (this[1] - compare[1])/(this[2] - compare[2])
}

tangram(data.frame(
  Strategy       = unname(unlist(strategies)),
  Costs          = unname(render_f(first(results), 2)),
  LifeExpectancy = unname(second(results)),
  ICER           = render_f(icer,0)
), caption="Decision Tree Exercise (Colorectal Cancer)", id="tbl1", style="nejm", 
as.character=TRUE)
```

Have a look at decision plane.

```{r}
plot(x=second(results), y=first(results), 
     xlab="Expected Life Expectancy", ylab="Cost ($)",
     pch=1:3, col=c("red", "darkgreen", "blue"))
lines(x=second(results), y=first(results), lty=2)
legend(3.2, 10500, 
       unname(unlist(strategies)),
       pch=1:3, col=c("red", "darkgreen", "blue"))
```

### Provided solution

Credits for the R Code: Petros Pechlivanoglou, Fernando Alarid- Escudero, Hawre Jalal and Mohammad Kaviul Kahn

Credits for the example: A. Gray et al 2011
*Applied Methods of Cost-effectiveness Analysis in Healthcare:
Cost effectiveness of follow-up strategies after colon cancer surgery*

Strategies: PC(Primary Care), HC (Hospital Care), RP (Routine Practice)

```{r}
#### 03 Input Model Parameters ####
## Strategy names
v.names.str <- c("Routine Practice", "Primary Care", "Hospital Care")  
## Number of strategies
n.str <- length(v.names.str)
## Decision tree parameters
p.PCed <- 0.40   # Probability of early detection PC
p.HCed <- 0.45   # Probability of early detection HC
p.RPed <- 0.35   # Probability of early detection RP 

le.ed  <- 7      # Life expectancy after early detection
le.ld  <- 1      # Life expectancy after  late detection 

c.PCed <-  3900  # Total costs after early detection with PC
c.HCed <-  6200  # Total costs after early detection with HC
c.RPed <-  3030  # Total costs after early detection with RP
c.PCld <- 12800  # Total costs after  late detection with PC
c.HCld <- 14400  # Total costs after  late detection with HC
c.RPld <- 12020  # Total costs after  late detection with RP
wtp    <- 10000  # Define willingness to pay threshold


#### 04 Run Decision Tree ####

# the solution of the tree is the sum of the weights (probabilities of each path) times the reward of each path

# for costs
c.RP <- p.RPed * c.RPed + (1 - p.RPed) * c.RPld # Routine Practice cost
c.PC <- p.PCed * c.PCed + (1 - p.PCed) * c.PCld # Primary Care cost
c.HC <- p.HCed * c.HCed + (1 - p.HCed) * c.HCld # Hospital Care cost

# ...and for effects
e.RP <- p.RPed * le.ed + (1 - p.RPed) * le.ld   # Routine Practice life expectancy
e.PC <- p.PCed * le.ed + (1 - p.PCed) * le.ld   # Primary Care life expectancy
e.HC <- p.HCed * le.ed + (1 - p.HCed) * le.ld   # Hospital Care life expectancy``

v.le <- c(e.RP, e.PC, e.HC)                       # vector of life expectancies
v.c  <- c(c.RP, c.PC, c.HC)                       # vector of total costs
names(v.le) <- names(v.c) <- v.names.str          # names for the elements of the two vectors

# Matrix with costs and effectiveness
m.ce <- data.frame(Strategy = v.names.str,
                   Cost     = v.c,
                   Effect   = v.le)

#### 05 Compute ICERs of Decision Tree ####
m.cea <- calculate_icers(m.ce)
m.cea
```

```{r}
#### 06 Plot frontier of Decision Tree ####
plot.frontier(CEmat = m.ce, frontier = getFrontier(m.ce, plot = F))
```

## Markov Modeling

### Exercise: Construct a Markov Model of the Sick-Sicker Disease 

In this exercise, we will model a hypothetical disease that affects individuals with
an average age of 25 years and results in increased mortality, increased healthcare
costs, and reduced quality of life. The disease has two levels; affected individuals
initially become sick but can subsequently progress and become sicker. Two
alternative strategies exist for this hypothetical disease: a no-treatment and a
treatment strategy. Under the treatment strategy, individuals in the sick and sicker
states are treated until they recover (only if sick; individuals in the sicker state
cannot recover) or die. The cost of the treatment is additive to the baseline
healthcare costs of being sick or sicker. The treatment improves quality of life for
those individuals who are sick but has no impact on the quality of life of those who
are sicker. Unfortunately, it is not possible to reliably differentiate between people
in the sick and sicker states, so treatment cannot be targeted to only those in the
sick state. You are asked to evaluate the cost-effectiveness of the treatment.

To model this disease, we will rely on a state-transition cohort model, called the
Sick-Sicker model, first described by Enns et al. The Sick-Sicker model consists of
four health states: Healthy (H), two disease states, Sick (S1) and Sicker (S2), and
Dead (D) (Figure 1). All individuals start in the Healthy state. Over time, healthy
individuals may develop the disease and can progress to S1. Individuals in S1 can
recover (return to state H), progress further to S2 or die. Individuals in S2 cannot
recover (i.e. cannot transition to either S1 or H). Individuals in H have a baseline
probability of death; individuals in S1 and S2 experience increased mortality
compared to those in the H state, given in terms of hazard ratios. These ratios are
used to calculate the probabilities of dying when in S1 and S2.

### Tasks

* Build the Markov model in R for no treatment and treatment strategies.
* Plot the survival curve for the cohort under no treatment.
* Estimate the cost-effectiveness of treatment vs no-treatment.
* Create a cost-effectiveness table with all results of interest.

```{r}
rm(list=ls())
source("Functions.R")

# Parameters
v.n    <- c("Healthy", "Sick", "Sicker", "Dead")
n.t    <-    30      # Time horizon

# Cycle => 1 year
d.r    <-     0.03   # Discount Rate

p.HS1  <-     0.15   # Disease Onset Probability / year       (H  -> S1)
p.S1H  <-     0.5    # Recovery Probability / year            (S1 -> H)
p.S1S2 <-     0.105  # Disease Progression Probability / year (S1 -> S2)
p.HD   <-     0.005  # Healthy to Dead probability / year     (H  -> D)
hr.S1D <-     3      # Hazard ratio in S1 vs healthy 
hr.S2D <-    10      # Hazard ratio in S2 vs healthy

# Annual Costs
c.H    <-  2000      # Healthy individuals 
c.S1   <-  4000      # Sick individuals in S1
c.S2   <- 15000      # Sick individuals in S2
c.D    <-     0      # Dead individuals
c.Trt  <- 12000      # Additional Annual cost for S1 and S2

# Utility Weights
u.H    <-     1.00   # Healthy
u.S1   <-     0.75   # S1
u.S2   <-     0.50   # S2
u.D    <-     0.00   # Dead

# Intervention Effect
u.Trt  <-     0.95   # S1 Utility for treatment in S1
```

**Note**: To calculate the probability of dying from S1 and S2, use the hazard ratios provided. To do so, first convert the probability of dying from healthy, p.HD, to a rate; then multiply this rate by the appropriate hazard ratio; finally, convert this rate back to a probability. Recall that you can convert between rates and probabilities using the following formulas:

$r=-\log(1-p)/\Delta$ and $p=1-e^{-r\Delta}$.

```{r}
hrf      <- function(p, h) 1-exp(log(1-p)*h)
discount <- 1 / (1 + d.r) ^ (0:n.t)

`%^%` <- function(m, n)
{
  if(n==0) return(diag(rep(1, dim(m)[1])))
  if(n==1) return(m)
  if(n==2) return(m %*% m)
  
  m %*% (m %^% (n-1))
}

markov <- function(time, m, i)
{
  result <- t(Vectorize(function(time, m, i) i %*% (m %^% time), vectorize.args="time")(time, m, i))
  colnames(result) <- colnames(m)
  result
}

cohort.tr <- matrix(
  c(
    0,     p.HS1,     0,      p.HD,
    p.S1H,     0,     p.S1S2, hrf(p.HD,hr.S1D), 
    0,         0,     0,      hrf(p.HD,hr.S2D),
    0,         0,     0,      0
  ), 
  dimnames=list(v.n, v.n),
  nrow=length(v.n), byrow=TRUE
)
diag(cohort.tr)     <- 1 - rowSums(cohort.tr)


solution <- markov(0:n.t, cohort.tr, c(1, 0, 0, 0))

matplot(solution, typ='l',
        ylab = "Probability of state occupancy",
        xlab = "Cycle",
        main = "Cohort Trace")
legend(20, 0.99, v.n,
       col = c("black", "red", "green", "blue"),
       lty = 1:4, bty = "n")  
```

```{r}
survival <- 1-solution[,"Dead"]

plot(0:n.t,
     survival,
     typ  = 'l',
     ylim = c(0, 1),
     ylab = "Survival probability",
     xlab = "Cycle",
     main = "Overall Survival")
grid(nx = n.t, ny = 10, col = "lightgray", lty = "dotted", lwd = par("lwd"), equilogs = TRUE) # add grid 

```

```{r}
prevalence <- rowSums(solution[,c("Sick", "Sicker")]) / survival
plot(prevalence,
     ylim = c(0, 1),
     ylab = "Prevalence",
     xlab = "Cycle",
     main = "Disease prevalence", 
     typ  = "l")
```


```{r, results='asis'}
#### 07 Compute Cost-Effectiveness Outcomes ####
#### 07.1 Mean Costs and QALYs ####
# per cycle
v.tc <- solution %*% c(c.H, c.S1, c.S2, c.D)  # calculate expected costs by multiplying m.M with the cost vector for the different health states   
v.tu <- solution %*% c(u.H, u.S1, u.S2, u.D)  # calculate expected QALYs by multiplying m.M with the utilities for the different health states   

#### 07.2 Discounted Mean Costs and QALYs ####
v.tc.d <-  t(v.tc) %*% discount   # Discount costs  by multiplying the cost vector with discount weights (v.dw) 
v.te.d <-  t(v.tu) %*% discount   # Discount QALYS  by multiplying the QALYs vector with discount weights (v.dw)

results <- data.frame( "Strategy" = "None",
                       "dCost" = v.tc.d, 
                       "Life Expectancy" = sum(survival), 
                       "dQALYs" = v.te.d, 
                       check.names = FALSE)

# Do it for treatment
v.tc <- solution %*% c(c.H, c.S1+c.Trt, c.S2+c.Trt, c.D)  # calculate expected costs by multiplying m.M with the cost vector for the different health states   
v.tu <- solution %*% c(u.H, u.Trt, u.S2, u.D)  # calculate expected QALYs by multiplying m.M with the utilities for the different health states   

#### 07.2 Discounted Mean Costs and QALYs ####
v.tc.d <-  t(v.tc) %*% discount   # Discount costs  by multiplying the cost vector with discount weights (v.dw) 
v.te.d <-  t(v.tu) %*% discount   # Discount QALYS  by multiplying the QALYs vector with discount weights (v.dw)


results <- rbind(results, 
  data.frame( "Strategy"        = "Treatment",
              "dCost"           = v.tc.d, 
              "Life Expectancy" = sum(survival), 
              "dQALYs"          = v.te.d, 
              check.names       = FALSE))

# Matrix with discounted costs and effectiveness
m.ce <- data.frame(Strategy = c("No Treatment", "Treatment") ,
                   Cost     = results$dCost,
                   Effect   = results$dQALYs)

results$ICER <- NA
results$ICER[2] <- render_f((results[2,2]-results[1,2])/(results[2,4]-results[1,4]), 0)

results$dCost             <- render_f(results$dCost,             0)
results$'Life Expectancy' <- render_f(results$'Life Expectancy', 2)
results$dQALYs            <- render_f(results$dQALYs,            2)

tangram(results, id="tbl2", caption="Markov Results", style="nejm", as.character=TRUE)
```

Check results
```{r}
plot(1-rowSums(solution[,1:4]), typ="l", ylab="Error", main="Numerical Error")
```

Plot decision plane.

```{r}
plot.frontier(CEmat = m.ce, frontier = getFrontier(m.ce, plot = F))
```

Thus concluding Day 1. 

# Day 2

## Exercise: Probabilistic sensitivity analysis of the Sick-Sicker Markov model

This exercise continues based on the time-homogeneous deterministic Markov
model of the Sick-Sicker model from exercise “Exercise-
SickSickerMarkovModel.docx”. In this exercise, you will do a probabilistic sensitivity
analysis (PSA) with 1000 simulations (n.sim). The Table describes the distributions
for the variables you used in the previous exercise.

### Tasks

1. Use the R function of the Sick-Sicker Markov model in the file “Markov_Sick-
Sicker - SA – Function.R”.
2. Generate values for the uncertain parameters using the appropriate
distributions. *Hint: package truncnorm deals with truncated normal distributions.*
3. Conduct a probabilistic Cost-Effectiveness analysis of treatment vs no-
treatment
4. Create histograms of model inputs.
5. Create a cost-effectiveness plane to present discounted costs and QALYs.
6. Create a cost-effectiveness acceptability curve for the treatment comparison
assuming WTP thresholds of $0 to $200,000.
7. Create an expected value of perfect information (EVPI) plot. Expected Value
of Perfect Information (EVPI)

```{r}
rm(list=ls())
source('Functions.R')

d.r <- 0.03
n.t <- 30

hrf      <- function(p, h) 1-exp(log(1-p)*h)
discount <- 1 / (1 + d.r) ^ (0:n.t)

# Markov Model solver
markov <- function(n.t, m, i)
{
  y <- unlist(Reduce(function(x, y) x %*% m, 1:n.t, i, accumulate=TRUE))
  y <- matrix(y, ncol=dim(m)[1], byrow=TRUE)
  colnames(y) <- colnames(m)
  y
}

# Sick Sicker Markov Model
MM.SickSicker <- function(params)
{
  v.n    <- c("Healthy", "Sick", "Sicker", "Dead")
  with(as.list(params), {
    cohort.tr <- matrix(
      c(
        0,     p.HS1,     0,      p.HD,
        p.S1H,     0,     p.S1S2, hrf(p.HD,hr.S1D), 
        0,         0,     0,      hrf(p.HD,hr.S2D),
        0,         0,     0,      0
      ), 
      dimnames=list(v.n, v.n),
      nrow=length(v.n), byrow=TRUE
    )
    diag(cohort.tr)     <- 1 - rowSums(cohort.tr)
    markov(n.t, cohort.tr, c(1, 0, 0, 0))
  })
}
  
# Expectation of Sick Sicker Model
Expect.SickSicker <- function(params)
{
  solution <- MM.SickSicker(params)
  
  with(as.list(params), {
    # No Treat
    tc_no_trt   <- solution %*% c(c.H, c.S1, c.S2, c.D)
    tu_no_trt   <- solution %*% c(u.H, u.S1, u.S2, u.D)
    d_tc_no_trt <- t(tc_no_trt) %*% discount
    d_tu_no_trt <- t(tu_no_trt) %*% discount
    
    # Treat
    tc_trt   <- solution %*% c(c.H, c.S1+c.Trt, c.S2+c.Trt, c.D) 
    tu_trt   <- solution %*% c(u.H, u.Trt, u.S2, u.D) 
    d_tc_trt <- t(tc_trt) %*% discount
    d_tu_trt <-  t(tu_trt) %*% discount  
    
    c(d_cost_no_trt = d_tc_no_trt,
      d_qaly_no_trt = d_tu_no_trt,
      d_cost_trt    = d_tc_trt,
      d_qaly_trt    = d_tu_trt)
  })
}

### Function to generate PSA input dataset
gen_psa <- function(n = 1000, seed = 071818)
{
  set.seed(seed)
  ### Dataframe of input parameters
  data.frame(
    ### Probabilities
    p.HS1  = rbeta(n, 30,  170),         # Disease Onset Probability / year       (H  -> S1)
    p.S1H  = rbeta(n, 60,   60),         # Recovery Probability / year            (S1 -> H)
    p.S1S2 = rbeta(n, 84,  716),         # Disease Progression Probability / year (S1 -> S2)
    p.HD   = rbeta(n, 10, 1990),         # Healthy to Dead probability / year     (H  -> D)
    hr.S1D = rlnorm(n, log( 3), 0.01),   # Hazard ratio in S1 vs healthy 
    hr.S2D = rlnorm(n, log(10), 0.02),   # Hazard ratio in S2 vs healthy
    
    ### Annual Costs
    c.H    = rgamma(n, 100, 1/20),       # Healthy individuals 
    c.S1   = rgamma(n, 1600/9, 4/90),    # Sick individuals in S1
    c.S2   = rgamma(n, 255, 3/200),      # Sick individuals in S2
    c.Trt  = rgamma(n, 73.46939, 3/490), # Additional Annual cost for S1 and S2
    c.D    = 0,                          # Dead individuals

    # Utility Weights
    u.H    = rtruncnorm(n, mean=1,    sd=0.01, b=1),   # Healthy
    u.S1   = rtruncnorm(n, mean=0.75, sd=0.02, b=1),   # S1
    u.S2   = rtruncnorm(n, mean=0.5,  sd=0.03, b=1),   # S2
    u.D    = 0,                                        # Dead

    # Intervention Effect
    u.Trt  = rtruncnorm(n, mean=0.95, sd=0.02, b=1)    # S1 Utility for treatment in S1
  )
}

n.sim <- 1000
n.str <- 2 # Number of strategies

m.psa.input <- gen_psa(n.sim)
ggplot(melt(m.psa.input, variable.name = "Parameter"), aes(x = value)) +
  facet_wrap(~Parameter, scales = "free") +
  geom_histogram(aes(y = ..density..), bins=30) +
  theme_bw(base_size = 8)
```

```{r}
strategies <- c("No Treatment", "Treatment")
psa   <- t(apply(m.psa.input, 1, Expect.SickSicker))
costs <- psa[,c(1, 3)]
qalys <- psa[,c(2, 4)]
colnames(costs) <- colnames(qalys) <- strategies
ScatterCE(strategies = strategies, m.c = costs, m.e = qalys)
```

```{r}
wtp <-  seq(0, 200000, by = 10000)
ceaf(v.wtp = wtp, strategies = strategies, m.e = qalys, m.c = costs)$gg.ceaf
```

```{r}
plot(evpi(v.wtp = wtp, m.e = qalys, m.c = costs))
```

## Exercise: Calibration of the Sick-Sicker Model

As you may recall, the Sick-Sicker model simulates the progression of a cohort of
healthy 25-year-olds at risk of developing a hypothetical disease with two stages of
illness: a Sick state (S1) and a Sicker state (S2). Individuals in S1 have increased
mortality, increased healthcare costs, and decreased quality of life relative to those
in the Healthy state. Individuals in S2 have even greater increases in mortality,
costs, and quality of life reductions.

Previously, you were provided with a full set of input parameters for this model.
However, “in reality” some of those input parameters can’t feasibly be estimated
directly from individual-level data and need to be estimated through calibration.
This is because while we can identify those who are afflicted with the illness
through obvious symptoms, we can’t easily distinguish those in the S1 state from
the those in the S2 state. Thus, we can’t directly estimate state-specific mortality
hazard ratios, nor do we know the transition probability of progressing from S1 to
S2.

There are three calibration targets to be used in this example: (1) observed
survival of a cohort over time; (2) disease prevalence in a cohort over time; and
(3) among sick patients (S1+S2), the proportion who are in the S1 state at three
points in time. The first two targets came from an observational study of a typical
cohort of individuals. The third target was obtained by subjecting ill patients to an
invasive procedure which can determine disease stage, but can’t be used routinely
due to its invasiveness.

The calibration target values are provided in the data file
“SickSickerTargets.RData”, which contains a list with three data frames: Surv, Prev,
and PropSick.
The tasks below will guide you through the process of calibrating the Sick-Sicker
model to estimate values for the unknown input parameters.

* Adapt the function of the Sick-Sicker Markov model R code in “Markov_Sick-
Sicker - SA - Function.R” so that the model returns model outputs that
correspond to the calibration targets. Make this model into a function that
can be called in the calibration process.
* Load the calibration targets and plot them over time.
* Implement a random search of the unknown parameters using Latin
hypercube sampling. Plot a histogram of the sampled parameter values.
* Run the Sick-Sicker Markov model for each of the sample parameter sets and
store the relevant model outputs.
* Calculate the fit of each model output to the calibration targets using a
normal likelihood goodness-of-fit and identify the best-fitting parameter set.
* Plot the model outputs corresponding to the best-fitting parameter set
against each calibration target. Visually, is the model well-calibrated to the
targets?

```{r}
load("SickSickerTargets.RData")
n.t <- 30
par(mfrow=c(1,3))
plotrix::plotCI(x = 1:n.t, y = l.targets$Surv$value, 
                ui = l.targets$Surv$ub,
                li = l.targets$Surv$lb,
                ylim = c(0, 1), 
                xlab = "Time", ylab = "Survival")

plotrix::plotCI(x = 1:n.t, y = l.targets$Prev$value, 
                ui = l.targets$Prev$ub,
                li = l.targets$Prev$lb,
                ylim = c(0, 1), 
                xlab = "Time", ylab = "Prevalance")

plotrix::plotCI(x = l.targets$PropSick$Time, y = l.targets$PropSick$value, 
                ui = l.targets$PropSick$ub,
                li = l.targets$PropSick$lb,
                ylim = c(0, 1), 
                xlab = "Time", ylab = "Proportion Sick")
```

```{r}

ll.SickSicker <- function(params, summary=FALSE)
{
  solution   <- MM.SickSicker(params)
  
  survival   <- 1-solution[2:(n.t+1),4]
  prevalance <- rowSums(solution[2:(n.t+1),c(2,3)]) / survival
  sick       <- solution[c(11, 21, 31), 2] / prevalance[c(10, 20, 30)]
  
  ll <-
    sum(dnorm(x    = l.targets$Surv$value, 
              mean = survival, 
              sd   = l.targets$Surv$se, 
              log  = TRUE)) +
    sum(dnorm(x    = l.targets$Prev$value, 
              mean = prevalance, 
              sd   = l.targets$Prev$se, 
              log  = TRUE)) +
    sum(dnorm(x    = l.targets$PropSick$value, 
              mean = sick, 
              sd   = l.targets$PropSick$se, 
              log  = TRUE))
  
  if(summary)
  {
    attr(ll, "survival")   <- survival
    attr(ll, "prevalance") <- prevalance
    attr(ll, "sick")       <- sick
  }
  
  ll
}

gen_lhs <- function(n = 10000, seed = 071918)
{
  set.seed(seed)
  lhs.samp <- randomLHS(n = n, k = 3)
  
  data.frame(
    ### Probabilities
    p.HS1  =     0.15,            # Disease Onset Probability / year       (H  -> S1)
    p.S1H  =     0.5,             # Recovery Probability / year            (S1 -> H)
    p.S1S2 = qunif(lhs.samp[,1], 0.01, 0.5), # Disease Progression Probability / year (S1 -> S2)
    p.HD   =     0.005,           # Healthy to Dead probability / year     (H  -> D)
    hr.S1D = qunif(lhs.samp[,2], 1, 4.5),   # Hazard ratio in S1 vs healthy 
    hr.S2D = qunif(lhs.samp[,3], 5, 15)     # Hazard ratio in S2 vs healthy
  )
}

lhs.grid <- gen_lhs()
cal   <- apply(lhs.grid, 1, ll.SickSicker)
hist(cal, freq=TRUE, main="Calibration Likelihoods")
```

```{r}
mll.lhs <- lhs.grid[which.max(cal),]
mll.lhs
```

```{r}
solution <- ll.SickSicker(mll.lhs, summary=TRUE)

par(mfrow=c(1,3))
plotrix::plotCI(x = 1:n.t, y = l.targets$Surv$value, 
                ui = l.targets$Surv$ub,
                li = l.targets$Surv$lb,
                ylim = c(0.5, 1), 
                xlab = "Time", ylab = "Pr Survive")
lines(x=1:n.t, attr(solution, "survival"), col='red', lty=2, lwd=2)

plotrix::plotCI(x = 1:n.t, y = l.targets$Prev$value, 
                ui = l.targets$Prev$ub,
                li = l.targets$Prev$lb,
                ylim = c(0, 1), 
                xlab = "Time", ylab = "Prevalance")
lines(x=1:n.t, attr(solution, "prevalance"), col='red', lty=2, lwd=2)

plotrix::plotCI(x = l.targets$PropSick$Time, y = l.targets$PropSick$value, 
                ui = l.targets$PropSick$ub,
                li = l.targets$PropSick$lb,
                ylim = c(0, 1), 
                xlab = "Time", ylab = "Proportion Sick")
lines(x=c(10, 20, 30), attr(solution, "sick"), col='red', lty=2, lwd=2)
```

```{r}
slice <- function(param1, a1, b1,
                  param2, a2, b2,
                  levels, 
                  optim,
                  n=50)
{
  x <- seq(a1, b1, by=(b1-a1)/(n-1))
  y <- seq(a2, b2, by=(b2-a2)/(n-1))
  z <- matrix(data=NA, nrow=50, ncol=50)
  
  for(i in 1:50)
  {
    for(j in 1:50)
    {
      ref <- optim
      ref[param1] <- x[i]
      ref[param2] <- y[j]
      z[i,j]      <- ll.SickSicker(ref)
    }
  }

  contour(x, y, z, levels=lines, xlab=param1, ylab=param2)
  points(optim[param1], optim[param2], pch=2, col="red", cex=2)
  legend("topright", "LHS MLE", col="red", pch=2)
}

lines <- round(quantile(cal, seq(0.1, 0.9, by=0.1)))

par(mfrow=c(1,3))
slice("p.S1S2", 0.01,  0.5,
      "hr.S1D", 1,     4.5,
       lines, mll.lhs)

slice("p.S1S2", 0.01,  0.5,
      "hr.S2D", 5,    15,
       lines, mll.lhs)

slice("hr.S1D", 1,     4.5,
      "hr.S2D", 5,    15,
       lines, mll.lhs)

```

# Day 3

## Exercise: Variations on the Sick-Sicker Markov Model

Previously, you built a Markov of the Sick-Sicker model where transition
probabilities were assumed to be constant over time. In this exercise, you will
expand on that model to incorporate age-dependence (time-varying probabilities)
and history-dependence.

### Part 1: Age-dependence

Healthy individuals are no longer assumed to have a fixed mortality rate. Their
mortality rate depends on their age. The Human Mortality Database (HMD)
(www.mortality.org) provides these age specific mortality rates (Mx1x1). You can
load this data in R using different packages, for example the HMDHFplus,
demography or data.table package. Registration (free) on the HMD website is
required in order to use the data. For this exercise, we provide you with this
mortality rate for the US in the file “HMD_USA_Mx_2015.csv”.
Remember: individuals in S1 and S2 still have an increased mortality relative to
healthy individuals, as described in the original exercise. The same hazard ratios
are used to calculate the probabilities of dying from S1 and S2 in this exercise.

* Use the R function “Markov_Sick-Sicker.R” and create a copy to then adapt
the model to account for age-dependency.
* Import the mortality rate data the “HMD_USA_Mx_2015.csv” file and store
this data in a variable called v.r.HD.
* Create probability to die when healthy as a function of age
$ p.HD <- 1 - exp(- v.r.HD*a)$
* Incorporate the age dependent mortality rate in the model.
* Create a survival curve of the cohort under no treatment. **Extra challenge: plot the survival curves with and without age-dependent probabilities of death in one graph so you can compare.**

```{r}
lt.usa.2005 <- read.csv("HMD_USA_Mx_2015.csv")

# Target population is age 25
p.HD <- 1-exp(-lt.usa.2005[lt.usa.2005$Age >= 25,'Total'])

# This function takes a transition probability matrix and current time
# Changes the mortality probability to be time based from 
mortality_ad <- function(m, a)
{ 
  m["Healthy", "Dead"]    <- p.HD[a]
  m["Healthy", "Healthy"] <- 1 - p.HD[a] - m["Healthy", "Sick"]
  m
}

# Markov Model solver with time dependent modification function
markov <- function(n.t, m, i, FUN)
{
  y <- unlist(Reduce(function(x, y) x %*% FUN(m, y), 1:n.t, i, accumulate=TRUE))
  y <- matrix(y, ncol=dim(m)[1], byrow=TRUE)
  colnames(y) <- colnames(m)
  y
}

# Sick Sicker Markov Model (with modified markov method)
MM.SickSicker <- function(params)
{
  v.n    <- c("Healthy", "Sick", "Sicker", "Dead")
  with(as.list(params), {
    cohort.tr <- matrix(
      c(
        0,     p.HS1,     0,      p.HD,
        p.S1H,     0,     p.S1S2, hrf(p.HD,hr.S1D), 
        0,         0,     0,      hrf(p.HD,hr.S2D),
        0,         0,     0,      0
      ), 
      dimnames=list(v.n, v.n),
      nrow=length(v.n), byrow=TRUE
    )
    diag(cohort.tr)     <- 1 - rowSums(cohort.tr)
    markov(n.t, cohort.tr, c(1, 0, 0, 0), function(m, a) m)
  })
}

# Sick Sicker Markov Model with Age Dependence
MMAG.SickSicker <- function(params)
{
  v.n    <- c("Healthy", "Sick", "Sicker", "Dead")
  with(as.list(params), {
    cohort.tr <- matrix(
      c(
        0,     p.HS1,     0,      p.HD,
        p.S1H,     0,     p.S1S2, hrf(p.HD,hr.S1D), 
        0,         0,     0,      hrf(p.HD,hr.S2D),
        0,         0,     0,      0
      ), 
      dimnames=list(v.n, v.n),
      nrow=length(v.n), byrow=TRUE
    )
    diag(cohort.tr)     <- 1 - rowSums(cohort.tr)
    markov(n.t, cohort.tr, c(1, 0, 0, 0), mortality_ad)
  })
}

params <- list(
  n.t    =    30,
  
  p.HS1  =     0.15,   # Disease Onset Probability / year       (H  -> S1)
  p.S1H  =     0.5,    # Recovery Probability / year            (S1 -> H)
  p.S1S2 =     0.105,  # Disease Progression Probability / year (S1 -> S2)
  p.HD   =     0.005,  # Healthy to Dead probability / year     (H  -> D)
  hr.S1D =     3,      # Hazard ratio in S1 vs healthy 
  hr.S2D =    10,      # Hazard ratio in S2 vs healthy,
  
  # Annual Costs
  c.H    =  2000,      # Healthy individuals 
  c.S1   =  4000,      # Sick individuals in S1
  c.S2   = 15000,      # Sick individuals in S2
  c.D    =     0,      # Dead individuals
  c.Trt  = 12000,      # Additional Annual cost for S1 and S2,
  
  # Utility Weights
  u.H    =     1.00,   # Healthy
  u.S1   =     0.75,   # S1
  u.S2   =     0.50,   # S2
  u.D    =     0.00,   # Dead,
  
  # Intervention Effect
  u.Trt  =     0.95    # S1 Utility for treatment in S1
)

noage <- MM.SickSicker(params)
w_age <- MMAG.SickSicker(params)

noage_surv <- 1-noage[,"Dead"]
w_age_surv <- 1-w_age[,"Dead"]

plot(0:params$n.t+25, noage_surv, ylim=c(0,1),
     xlab="Age", ylab="Survival Probability",
     main="Overall Survival", typ='l')
grid(nx = params$n.t, ny = 10, col = "lightgray", lty = "dotted", lwd = par("lwd"), equilogs = TRUE)
lines(0:params$n.t+25, w_age_surv, lty=2, col='red')
legend("bottomleft", c("Time Homogeneous", "Age-Dependent"), col=c("black", "red"),
       lty=1:2)
```